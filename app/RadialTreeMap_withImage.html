<!doctype html>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>


<style>

.node {
  cursor: pointer;
}

.node circle {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node text {
  font: 16px arial;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

</style>
<script>
$(document).ready(function(){
	
var margin = {top: 20, right: 120, bottom: 20, left: 120},
    width = 960 - margin.right - margin.left,
    height = 800 - margin.top - margin.bottom;
	    
var i = 0,
    duration = 750,
    root, rad, circlefillColor;
	
	var diameter = 800;
	
var tree = d3.layout.tree()
    .size([360, diameter / 2 - 100])
    .separation(function(a, b) { 
		return (a.parent == b.parent ? 1 : 2) / a.depth; 
	});

var diagonal = d3.svg.diagonal.radial()
    .projection(function(d) { 
		return [d.y, d.x / 180 * Math.PI]; 
	});

	//This is the accessor function we talked about above
var lineFunction = d3.svg.line()
                         .x(function(d) { return d.x; })
                         .y(function(d) { return d.y; })
                         .interpolate("linear");
	
var svg = d3.select("body").append("svg")
    .attr("width", diameter)
    .attr("height", diameter - 50)
  .append("g")
    .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

d3.json("radialNodeTree.json", function(error, flare) {
  root = flare;
  root.x0 = diameter / 2;
  root.y0 = 0;

  function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  root.children.forEach(collapse);
  update(root);
});

d3.select(self.frameElement).style("height", "800px");

function update(source) {

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse(),
      links = tree.links(nodes);

  // Normalize for fixed-depth.
  
 // nodes.forEach(function(d) { d.y = d.depth * 180; }); // SC commented

  // Update the nodes…
  var node = svg.selectAll("g.node")
      .data(nodes, function(d) { 
		return d.id || (d.id = ++i); 
	  });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { 
	  //return "translate(" + source.y0 + "," + source.x0 + ")"; // SC commented
	  return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; 
	  })
      .on("click", click);

	 nodeEnter.filter(function(d) { return d.depth ==1 }).append("image")
    .attr("xlink:href", "event.jpg")
    .attr("width", 50)
    .attr("height", 40); 
	  
  nodeEnter.filter(function(d) { return d.depth ==0 || d.depth ==2 }).append("circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { 
	  return d._children ? "lightsteelblue" : "#fff"; 
	  });

  nodeEnter.append("text")
      .attr("x", function(d) { 
	  return d.children || d._children ? -10 : 10; 
	  })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { 
	  return d.children || d._children ? "end" : "start"; 
	  })
      .attr("transform", function(d) { 
		if(d.depth ==0){  
			return  d.x < 180 ? "translate(8)" : "rotate(270)translate(25)";
		}
		else if(d.depth ==1){
			return d.x < 180 ? "translate(-20)" : "rotate(180)translate(80)"; 
		}
		else{ 
		  return  d.x < 180 ? "translate(8)" : "rotate(180)translate(-80)";
		 }
	  })
      .text(function(d) { return d.name; })
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { 
	  //return "translate(" + d.y + "," + d.x + ")"; } // SC commented
	    return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; 
	   }
	  );

  nodeUpdate.select("circle")
      .attr("r", function(d) { 
		  rad= 10;
		  if(d.depth==0){rad= 50;}
		  else if(d.depth==1){rad= 15;}
		  return rad;
	  })
      .style("fill", function(d) { 
		circlefillColor= "#fff";
		  if(d.depth==0){circlefillColor = "#395775";}
		  else if(d.depth==1){circlefillColor = "lightsteelblue";}
		  return circlefillColor;
		//return d._children ? "lightsteelblue" : "#fff";
	  });

   nodeUpdate.select("image")
      .attr("transform", function(d) { 
	  return  d.x < 180 ? "rotate(" + (d.x - 90)*-1 + ")translate(-10,-10)" : "rotate(" + (d.x - 90)*-1 + ")translate(-30,-10)";
			//return "rotate(" + (d.x - 90)*-1 + ")translate(0,-20)"; 
			 // return  d.x < 180 ? "rotate(-20)translate(1 , -15)" : "rotate(-180)translate(8)";
			 //return "rotate(1)translate(1)"; 
	  });
	  
  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { 
		return "translate(" + source.y + "," + source.x + ")"; 
	  })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = svg.selectAll("path.link")
      .data(links, function(d) {
	  return d.target.id; 
	  });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
		//return lineFunction([ { "x": source.x0,   "y": source.y0},  { "x": d.target.x,  "y": d.target.y}]);
      });

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
	   //return lineFunction([ { "x": source.x0,   "y": source.y0},  { "x": d.target.x,  "y": d.target.y}]);
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

// Toggle children on click.
function click(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
  update(d);
}
});

</script>
</head>
<body>
<h2> Radial layout Tree Chart (Collapsible)</h2>
</body>
</html>